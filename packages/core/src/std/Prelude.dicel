-- Boolean

(||) :: Bool -> Bool -> Bool
True  || _ = True
False || y = y

(&&) :: Bool -> Bool -> Bool
False && _ = False
True  && y = y

not :: Bool -> Bool
not True = False
not False = True

-- Number

(+) :: Num -> Num -> Num
(+) = addNum

(-) :: Num -> Num -> Num
(-) = subNum

(*) :: Num -> Num -> Num
(*) = mulNum

(/) :: Num -> Num -> Num
(/) = divNum

(%) :: Num -> Num -> Num
(%) = modNum

(==) :: Num -> Num -> Bool
(==) = eqNum

(/=) :: Num -> Num -> Bool
(/=) x y = not (x == y)

(<) :: Num -> Num -> Bool
(<) = ltNum

(>) :: Num -> Num -> Bool
(>) = gtNum

(<=) :: Num -> Num -> Bool
(<=) = leNum

(>=) :: Num -> Num -> Bool
(>=) = geNum

inf :: Num
inf = 1 / 0

neg :: Num -> Num
neg x = 0 - x

min :: Num -> Num -> Num
min x y = if x < y then x else y

max :: Num -> Num -> Num
max x y = if x > y then x else y

abs :: Num -> Num
abs x = if x < 0 then neg x else x

-- Function

id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

(|>) :: a -> (a -> b) -> b
x |> f = f x

($) :: (a -> b) -> a -> b
f $ x = f x

(<<) :: (b -> c) -> (a -> b) -> a -> c
(f << g) x = f (g x)

(>>) :: (a -> b) -> (b -> c) -> a -> c
(f >> g) x = g (f x)

-- List

map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs

(<$>) = map
infixl 4 <$>

filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) =
  let xs' = filter p xs
  in  if p x then x:xs' else xs'

sort :: [Num] -> [Num]
sort [] = []
sort (p:xs) =
  let smallers = filter (< p) xs
      biggers = filter (>= p) xs
  in  sort smallers ++ (p : sort biggers)

(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)

take :: Num -> [a] -> [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n - 1) xs

drop :: Num -> [a] -> [a]
drop 0 xs = xs
drop _ [] = []
drop n (x:xs) = drop (n - 1) xs

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)

-- Maybe

data Maybe a = Just a | Nothing

listToMaybe :: [a] -> Maybe a
listToMaybe [] = Nothing
listToMaybe (x:_) = Just x

maybeToList :: Maybe a -> [a]
maybeToList Nothing = []
maybeToList (Just x) = [x]

-- Tuple

data Solo a = MkSolo a

fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y

-- Either

data Either a b = Left a | Right b

-- Ordering

data Ordering = LT | EQ | GT
