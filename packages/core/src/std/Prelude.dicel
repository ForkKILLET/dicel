-- Boolean

data Bool = True | False

(||) :: Bool -> Bool -> Bool
(||) = \x y -> case x of
  True -> True
  False -> y

(&&) :: Bool -> Bool -> Bool
(&&) = \x y -> case x of
  True -> y
  False -> False

not :: Bool -> Bool
not = \x -> case x of
  True -> False
  False -> True

-- Number

inf :: Num
inf = 1 / 0

-- Function

id :: a -> a
id = \x -> x

const :: a -> b -> a
const = \x y -> x

flip :: (a -> b -> c) -> b -> a -> c
flip = \f x y -> f y x

(|>) :: a -> (a -> b) -> b
(|>) = \x f -> f x

($) :: (a -> b) -> a -> b
($) = \f x -> f x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) = \f g x -> f (g x)

-- List

map :: (a -> b) -> [a] -> [b]
map = \f xs -> case xs of
  [] -> []
  x#xs -> f x # map f xs

filter :: (a -> Bool) -> [a] -> [a]
filter = \p xs -> case xs of
  [] -> []
  x#xs ->
    let xs' = filter p xs
    in p x ? x#xs' : xs'

(<$>) = map
infixl 4 <$>

(++) :: [a] -> [a] -> [a]
(++) = \xs ys ->
  case xs of
    [] -> ys
    x#xs -> x # (xs ++ ys)

take :: Num -> [a] -> [a]
take = \n xs -> case (n, xs) of
  (0, _) -> []
  (_, []) -> []
  (n, x#xs) -> x # take (n - 1) xs

drop :: Num -> [a] -> [a]
drop = \n xs -> case (n, xs) of
  (0, _) -> xs
  (_, []) -> []
  (n, x#xs) -> drop (n - 1) xs

-- Maybe

data Maybe a = Just a | Nothing

listToMaybe :: [a] -> Maybe a
listToMaybe = \case
  [] -> Nothing
  x#_ -> Just x

maybeToList :: Maybe a -> [a]
maybeToList = \case
  Nothing -> []
  Just x -> [x]

-- Tuple

data Solo a = MkSolo a

fst :: (a, b) -> a
fst = \(x, _) -> x

snd :: (a, b) -> b
snd = \(_, y) -> y

-- Either

data Either a b = Left a | Right b

-- Ordering

data Ordering = LT | EQ | GT
